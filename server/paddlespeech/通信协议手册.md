# PaddleSpeech Server 设计规范手册

作者：南风LI (GitHub: wzyforgit)

本设计规范手册在 CC BY-ND 4.0 协议下发布，如需转载或引用，请遵循此协议的规范

## 概述

&emsp;&emsp;由于 `PaddleSpeech` 只能使用对应的 `Python client` 方面的 API 调用，且 client 上必须处于完整的 `PaddleSpeech` 环境中。但为了保护部署机的系统环境，我们无法直接在宿主机上安装 `PaddleSpeech`，进而导致我们无法使用 `C++` 代码直接和位于虚拟环境中的 `PaddleSpeech` 通信，只能重新制作一个中转用的 `Server` 来对接我们的 `C++` 程序和 `PaddleSpeech` 模块。

&emsp;&emsp;本文主要描述以下内容，以规范服务端程序和客户端程序的开发：

- 服务端应当完成的一些基本内容
- 底层数据封包规范
- 主要协议规范

## 服务端应当完成的一些基本内容

&emsp;&emsp;根据过往经验，服务端应当具备以下基本能力：

- 能够处理多个不同来源的不同的转换需求
- 能够成为守护进程挂在系统后台自动作业，并能接收和执行退出信号
- 使用单一脚本进行起停
- 建立命令缓存队列，且不能因为正在处理数据而无法响应进入的命令
- 使用 `TCP` 协议和客户端程序进行通信

## 底层数据封包规范

&emsp;&emsp;数据封包采用最简化设计原则执行：

- 数据包仅有两个部分：数据的字节数 + 数据本体
- 数据的字节数固定使用两个字节表示，为无符号大端的形式，即 `char bytesCount[] = {0x10, 0x21}` 表示后续的数据长度为 0x1021，即后续的数据有 4129 个字节
- 数据的内容决定了服务端和客户端的通信规则，为了简化设计，此处只采用标准 JSON 字符串作为数据的载体

## 主要数据协议规范

&emsp;&emsp;根据目前 `PaddleSpeech` 已实装的功能：语音转文字、语音合成、语音场景分类、声纹识别、文本标点恢复、语音翻译，此处将会给每一个功能单独制定一个通信用数据包格式，同时再加上发起会话和结束会话的通信包协议即组成完整的规范。

### 数据包协议基本设计原则

- 需要使用启动会话功能进行握手才能进行后续功能，长时间不发送内容则会导致服务端断开连接
- 可以使用结束会话功能主动断开连接
- 启动会话成功后，服务端会分配一个 `token` 给客户端，客户端需要使用此 `token` 完成后续的通信
- 所有需要传送文件的功能（比如语音转文字），需要发起端把文件写入对应位置后才能发起功能请求（后续也许可以实现一个文件传输能力？）
- 所有的功能请求均需要使用 `task_id` 的形式进行表述，`task` 为该功能的缩写，`id` 为客户端自行生成的编号，这部分将作为服务端返回的数据是对应哪个请求的依据

### 数据包协议具体内容

#### 会话相关

- 启动会话
```json
//客户端发送：
{
    "key" : "123321", //在服务端上登记的帐号
    "pwd" : "321123"  //帐号对应的密码
}
//服务端响应：
{
    "status" : "ok",  //会话启动成功
    "token"  : "2333" //后续客户端使用此token使用服务端的功能
}
```
- 关闭会话
```json
//客户端发送：
{
    "token" : "2333",  //客户端的会话token
    "task"  : "fin_id" //功能代号fin，表示结束会话；id为本次功能请求的id号，由客户端自行生成
}
//服务端响应：
{
    "token" : "2333",   //客户端的会话token
    "task"  : "fin_id", //功能代号fin，表示结束会话；id为本次功能请求的id号，是此前客户端交给服务端的id号
    "status": "ok"      //关闭会话成功，随后服务端会断开TCP连接
}
```
- 服务端错误响应
```json
{
    "status" : "error_01", //服务端出现错误；01为错误代码
    "reason" : "key or password error" //错误原因的字符串表述
}
```

#### 功能相关

- 语音转文字
```json
//客户端发送：
{
    "token" : "2333",    //客户端的会话token
    "task"  : "asr_id",  //功能代号asr，表示语音转文字；id为本次功能请求的id号，由客户端自行生成
    "file_token" : "123" //完整文件名应该是: 2333_123.wav，存放于服务器指定的路径下
}
//服务端响应：
{
    "token"  : "2333",   //客户端的会话token
    "task"   : "asr_id", //功能代号asr，表示语音转文字；id为本次功能请求的id号，是此前客户端交给服务端的id号
    "status" : "ok",     //语音转文字执行成功
    "result" : "我认为跑步最重要的就是给我带来了身体健康" //语音转文字的执行结果
}
```
- 语音合成
```json
//客户端发送：
{
    "token" : "2333",
    "task"  : "tts_id", //功能代号tts，表示语音合成
    "type"  : "01",     //语音合成调用的音色代码
    "text"  : "123321"  //需要朗读的文本内容
}
//服务端响应：
{
    "token"  : "2333",
    "task"   : "tts_id",
    "status" : "ok",
    "file_token" : "123" //完整文件名应该是: 2333_123.wav，存放于服务器指定的路径下
}
```
- 语音场景分类
```json
//客户端发送：
{
    "token" : "2333",
    "task"  : "cls_id", //功能代号cls，表示语音场景分类
    "file_token" : "123"
}
//服务端响应：
{
    "token"  : "2333",
    "task"   : "cls_id",
    "status" : "ok",
    "result" : "Speech 0.9027186632156372" //分类结果和置信度
}
```
- 声纹识别
```json
//客户端发送：
{
    "token" : "2333",
    "task"  : "vector_id", //功能代号vector，表示声纹识别
    "file_token" : "123"
}
//服务端响应：
{
    "token"  : "2333",
    "task"   : "vector_id",
    "status" : "ok",
    "result" : [-0.19083306,9.474295,-14.122263,-2.0916545] //提取到的声纹特征向量
}
```
- 文本标点恢复
```json
//客户端发送：
{
    "token" : "2333",
    "task"  : "text_id", //功能代号text，表示文本标点恢复
    "text"  :  "123"     //需要恢复标点的文本
}
//服务端响应：
{
    "token"  : "2333",
    "task"   : "text_id",
    "status" : "ok",
    "result" : "1,2,3." //已完成标点恢复的文本内容
}
```
- 语音翻译
```json
//客户端发送：
{
    "token" : "2333",
    "task"  : "st_id", //功能代号st，表示语音翻译，目前暂时只支持英译中
    "src_lang" : "en", //原始音频语言
    "tgt_lang" : "zh", //目标翻译语言
    "file_token" : "123"
}
//服务端响应：
{
    "token"  : "2333",
    "task"   : "st_id",
    "status" : "ok",
    "result" : "123321" //翻译后的文本
}
```
